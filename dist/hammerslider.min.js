'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function HammerSlider(_this, options) {
  'use strict';

  // Main declarations

  var SLIDER = {
    contentWidth: undefined,
    container: undefined,
    slides: undefined,
    dotContainer: undefined,
    dots: undefined,
    slideData: undefined,
    transform: undefined,
    currentSlideIndex: undefined,
    lastSlideIndex: undefined,
    isLastSlide: undefined,
    currentDistance: undefined,
    eventListeners: undefined
  };

  // Default options
  var OPTIONS = {
    slideShow: false,
    slideInterval: 5000,
    slideSpeed: 1200,
    //touchSpeed: 800,
    startSlide: 0,
    alignSlides: 'center',
    dragThreshold: 10,
    minimumDragDistance: 30,
    stopAfterInteraction: true,
    infinite: true,
    mouseDrag: false,
    dotContainer: undefined,
    beforeSlideChange: undefined,
    afterSlideChange: undefined,
    onSetup: undefined,
    classPrefix: 'c-slider'
  };

  // Merge user options into defaults
  options && mergeObjects(OPTIONS, options);

  // Class names
  var CLASSES = {
    container: OPTIONS.classPrefix + '__container',
    slide: OPTIONS.classPrefix + '__slide',
    dotContainer: OPTIONS.classPrefix + '__dots',
    dotItem: OPTIONS.classPrefix + '__dot',
    dotActiveClass: OPTIONS.classPrefix + '__dot--is-active',
    dragging: OPTIONS.classPrefix + '__container--is-dragging',
    mouseDrag: OPTIONS.classPrefix + '__container--mouse-drag-enabled'
  };

  // Change to Object.assign()
  function mergeObjects(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
    return target;
  }

  function getElementChildren(element, selector, all) {
    return element && element['querySelector' + (all ? 'All' : '')](selector);
  }

  function addEvent(element, event, func, bool) {
    element.addEventListener(event, func, !!bool);
    return { remove: function remove() {
        return element.removeEventListener(event, func, !!bool);
      } };
  }

  function addClass(element, className) {
    element && element.classList.add(className);
  }

  function removeClass(element, className) {
    element && element.classList.remove(className);
  }

  function forEachItem(array, callback, startIndex) {
    for (var index = startIndex || 0; index < array.length; index += 1) {
      var returnValue = callback(array[index], index, array);
      if (returnValue) return returnValue;
    }
    return false;
  }

  function getItemsAsArray(nodeList) {
    var returnArray = [];
    if (nodeList) forEachItem(nodeList, function (item) {
      returnArray.push(item);
    });
    return returnArray;
  }

  function getPercentageOfTotal(fraction, total) {
    return fraction / total * 100;
  }

  function getSupportedProperty(property) {
    var prefixes = ['', 'webkit', 'moz', 'ms', 'o'];
    var div = document.createElement('div');

    return forEachItem(prefixes, function (prefix) {
      var formattedProperty = '' + (prefix ? '-' + prefix + '-' : '') + property;
      if (typeof div.style[formattedProperty] !== 'undefined') return formattedProperty;
    });
  }

  function getCurrentTranslate(element) {
    var transform = window.getComputedStyle(element, null).getPropertyValue(SLIDER.transform);
    var transformType = transform.match('matrix3d') ? 12 : 4;
    var transformValue = parseFloat(transform.split(',')[transformType]);
    return getPercentageOfTotal(transformValue, element.offsetWidth);
  }

  function setTranslate(element, value, threeD) {
    var type = threeD ? '3d' : 'X';
    var translate = function translate(to) {
      return element.style[SLIDER.transform] = 'translate' + type + '(' + to + '%' + (threeD ? ',0,0' : '') + ')';
    };
    if (value !== false) translate(value);
    return translate;
  }

  /* ------ Item calculations ------ */

  function setItemWidth(containerWidth) {
    return function (item, index) {
      var width = Math.round(getPercentageOfTotal(item.element.offsetWidth, containerWidth));
      return mergeObjects(item, { width: width });
    };
  }

  function setItemAlignment(alignment) {
    var align = {
      left: function left() {
        return 0;
      },
      center: function center(width) {
        return (100 - width) / 2;
      },
      right: function right(width) {
        return 100 - width;
      }
    };
    return align[alignment] || align['center'];
  }

  function setItemAlignDistance(alignItem) {
    return function (item, index, itemArray) {
      var alignDistance = alignItem(item.width);
      return mergeObjects(item, { alignDistance: alignDistance });
    };
  }

  function setDistanceToItem() {
    return function (item, index, itemArray) {
      var distanceToThis = itemArray.reduce(function (accumulator, _ref, innerIndex) {
        var width = _ref.width;

        if (innerIndex > index) return accumulator;
        return accumulator + (innerIndex === index ? item.alignDistance : -width);
      }, 0);
      return mergeObjects(item, { distanceToThis: distanceToThis });
    };
  }

  function setDistanceBetweenItems(lastItemIndex) {
    return function (item, index, itemArray) {
      var nextItemIndex = !index ? lastItemIndex : index - 1;
      var distanceToNext = itemArray[nextItemIndex].distanceToThis - item.distanceToThis;
      return mergeObjects(item, { distanceToNext: distanceToNext });
    };
  }

  function setItemDistanceToFlip(lastItemIndex) {
    return function (item, index, itemArray) {
      var distanceToFlip = itemArray.reduce(function (accumulator, _ref2) {
        var width = _ref2.width;
        return accumulator + getPercentageOfTotal(width, item.width);
      }, 0);
      return mergeObjects(item, { distanceToFlip: distanceToFlip });
    };
  }

  function setSlideData(container, items, lastItemIndex) {
    var setSlideWidth = setItemWidth(container.offsetWidth);
    var setSlideAlignDistance = setItemAlignDistance(setItemAlignment(OPTIONS.alignSlides));
    var setDistanceToSlide = setDistanceToItem();
    var setDistanceBetweenSlides = setDistanceBetweenItems(lastItemIndex);
    var setSlideDistanceToFlip = setItemDistanceToFlip(lastItemIndex);

    var slideData = [].concat(_toConsumableArray(items)).map(function (element) {
      return { element: element };
    }).map(setSlideWidth).map(setSlideAlignDistance).map(setDistanceToSlide).map(setDistanceBetweenSlides).map(setSlideDistanceToFlip);

    // Infinite sliding specific calculations - Move to separate func
    if (OPTIONS.infinite) {
      SLIDER.contentWidth = slideData.reduce(function (accumulator, _ref3) {
        var width = _ref3.width;
        return accumulator + width;
      }, 0);
      slideData[0].distanceToNext += SLIDER.contentWidth;
    }
    return slideData;
  }

  /* ------ Bound calculations ------ */

  function getItemsWithinGap(gapWidth, direction, itemIndex) {
    var items = [];
    var accumulator = 0;

    return forEachItem(SLIDER.slideData, function (item, index, itemArray) {
      if (accumulator >= gapWidth) return items;
      itemIndex = getNextItemIndex(itemIndex, direction);
      accumulator += itemArray[itemIndex].width;
      items.push(itemIndex);
    });
  }

  function getBoundItems() {
    var gapToFirstSlide = SLIDER.slideData[0].distanceToThis;
    var leftGapWidth = gapToFirstSlide + 1;
    var rightGapWidth = 100 - leftGapWidth + 2;
    var itemsToLeft = getItemsWithinGap(leftGapWidth, -1, 0);
    var itemsToRight = getItemsWithinGap(rightGapWidth, 1, SLIDER.lastSlideIndex);

    return {
      items: itemsToLeft.concat(itemsToRight),
      itemsToLeft: itemsToLeft,
      itemsToRight: itemsToRight
    };
  }

  function getBoundItemPosition(item, direction, isBoundItemToRight) {
    var position = {
      '1': isBoundItemToRight ? 0 : item.distanceToFlip * -1,
      '-1': isBoundItemToRight ? item.distanceToFlip : 0
    };
    return position[direction];
  }

  function positionBoundItems(direction) {
    var isBoundItemToRight = false;

    SLIDER.boundData.items.forEach(function (itemIndex) {
      if (!itemIndex) isBoundItemToRight = true;
      var item = SLIDER.slideData[itemIndex];
      var position = getBoundItemPosition(item, direction, isBoundItemToRight);
      setTranslate(item.element, position);
      mergeObjects(item, { position: position });
    });
  }

  function getBoundStartIndex(items, direction) {
    var itemBoundIndex = items[items.length - 2] || 0;
    var itemToFlipIndex = getNextItemIndex(itemBoundIndex, direction);

    return { itemBoundIndex: itemBoundIndex, itemToFlipIndex: itemToFlipIndex };
  }

  function setBoundData() {
    var boundData = getBoundItems();
    var leftBoundStartIndex = getBoundStartIndex(boundData.itemsToLeft, -1);
    var rightBoundStartIndex = getBoundStartIndex(boundData.itemsToRight, 1);

    mergeObjects(boundData, { '1': leftBoundStartIndex });
    mergeObjects(boundData, { '-1': rightBoundStartIndex });

    SLIDER.boundData = boundData;
    positionBoundItems(1);
  }

  /* DO HUGE REFACTOR BELOW */
  function flip(position, direction) {
    var slideData = SLIDER.slideData;
    var firstSlide = slideData[0];

    // Forward
    if (direction === 1) {
      var _ret = function () {
        var currentBound = SLIDER.boundData[direction];
        var boundItem = slideData[currentBound.itemBoundIndex];
        var flipItem = slideData[currentBound.itemToFlipIndex];

        if (position < -SLIDER.contentWidth + firstSlide.alignDistance + 1) {
          mergeObjects(currentBound, getBoundStartIndex(SLIDER.boundData.itemsToLeft, -1));
          positionBoundItems(direction);
          return {
            v: true
          };
        }

        var bound = function () {
          if (SLIDER.boundData.items.indexOf(currentBound.itemToFlipIndex) < 0) return;

          var itemBound = boundItem.distanceToThis - boundItem.alignDistance - 1;
          var distance = itemBound;

          if (boundItem.position === boundItem.distanceToFlip * -1) {
            distance += SLIDER.contentWidth;
          } else if (boundItem.position === boundItem.distanceToFlip) {
            distance -= SLIDER.contentWidth;
          }

          return distance;
        }();

        if (!bound) return {
            v: void 0
          };

        if (position < bound) {
          var itemPosition = flipItem.position + flipItem.distanceToFlip;
          mergeObjects(flipItem, { position: itemPosition });

          var opposite = direction * -1;
          var oppositeBound = SLIDER.boundData[opposite];
          mergeObjects(oppositeBound, {
            itemBoundIndex: getNextItemIndex(oppositeBound.itemBoundIndex, direction),
            itemToFlipIndex: currentBound.itemToFlipIndex
          });

          mergeObjects(currentBound, {
            itemBoundIndex: getNextItemIndex(currentBound.itemBoundIndex, direction),
            itemToFlipIndex: getNextItemIndex(currentBound.itemToFlipIndex, direction)
          });
          setTranslate(flipItem.element, itemPosition);
        }
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    } else {
      var _ret2 = function () {
        var currentBound = SLIDER.boundData[direction];
        var boundItem = slideData[currentBound.itemBoundIndex];
        var flipItem = slideData[currentBound.itemToFlipIndex];

        if (position > firstSlide.alignDistance - 1) {
          mergeObjects(currentBound, getBoundStartIndex(SLIDER.boundData.itemsToRight, 1));
          positionBoundItems(direction);
          return {
            v: true
          };
        }

        var bound = function () {
          if (SLIDER.boundData.items.indexOf(currentBound.itemToFlipIndex) < 0) return;

          var itemBound = boundItem.distanceToThis - boundItem.alignDistance + (100 - boundItem.width + 1);
          var distance = itemBound;

          if (boundItem.position === boundItem.distanceToFlip * -1) {
            distance += SLIDER.contentWidth;
          } else if (boundItem.position === boundItem.distanceToFlip) {
            distance -= SLIDER.contentWidth;
          }

          return distance;
        }();

        if (!bound) return {
            v: void 0
          };

        if (position > bound) {
          var itemPosition = flipItem.position - flipItem.distanceToFlip;
          mergeObjects(flipItem, { position: itemPosition });

          var opposite = direction * -1;
          var oppositeBound = SLIDER.boundData[opposite];
          mergeObjects(oppositeBound, {
            itemBoundIndex: getNextItemIndex(oppositeBound.itemBoundIndex, direction),
            itemToFlipIndex: currentBound.itemToFlipIndex
          });

          mergeObjects(currentBound, {
            itemBoundIndex: getNextItemIndex(currentBound.itemBoundIndex, direction),
            itemToFlipIndex: getNextItemIndex(currentBound.itemToFlipIndex, direction)
          });
          setTranslate(flipItem.element, itemPosition);
        }
      }();

      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
    }
  }
  /* DO HUGE REFACTOR ABOVE */

  function isLastItemIndex(lastIndex) {
    return function (index) {
      return index === lastIndex;
    };
  }

  function getNextItemIndex(currentItemIndex, direction) {
    if (direction === 1) {
      if (SLIDER.isLastSlide(currentItemIndex)) return 0;
    } else if (!currentItemIndex) {
      return SLIDER.lastSlideIndex;
    }
    return currentItemIndex + direction;
  }

  function slideTo(direction, jumpTo) {
    /* Clean this mess up */
    stopSlideshow();
    var currentSlideIndex = direction ? getNextItemIndex(SLIDER.currentSlideIndex, direction) : jumpTo;
    var currentDistance = void 0;

    if (direction) {
      var index = direction === 1 ? currentSlideIndex : getNextItemIndex(currentSlideIndex, 1);
      currentDistance = SLIDER.currentDistance - SLIDER.slideData[index].distanceToNext * direction;
    } else {
      /*
      if ((!SLIDER.currentSlideIndex && SLIDER.isLastSlide(jumpTo)) || (SLIDER.isLastSlide(SLIDER.currentSlideIndex) && !jumpTo)) {
        slideTo(slideDirection * -1);
        return;
      }
      */
      currentDistance = SLIDER.slideData[jumpTo].distanceToThis;
    }

    mergeObjects(SLIDER, { currentSlideIndex: currentSlideIndex, currentDistance: currentDistance });
    if (OPTIONS.beforeSlideChange) OPTIONS.beforeSlideChange(currentSlideIndex);

    setActiveDot(currentSlideIndex);
    animate(currentDistance);
  }

  function animate(slideDistance) {
    /* Clean this mess up */
    var translate = setTranslate(SLIDER.container, false, true);
    var slideSpeed = OPTIONS.slideSpeed;
    var increment = 20;

    var currPos = getCurrentTranslate(SLIDER.container);
    var currentTime = 0;
    var start = currPos;
    var change = slideDistance - start;

    var direction = slideDistance < currPos ? 1 : -1;

    function render() {
      // Sliding ended
      if (currentTime > slideSpeed) {}
      //shouldResumeSlideshow(autoSlide);
      //OPTIONS.afterSlideChange && OPTIONS.afterSlideChange();

      // Else
      else {
          if (OPTIONS.infinite && flip(currPos, direction)) {
            SLIDER.currentDistance += SLIDER.contentWidth * direction;
            start += SLIDER.contentWidth * direction;
          }
          currPos = easeOutQuint(currentTime, start, change, slideSpeed);
          currentTime += increment;
          translate(currPos);
          SLIDER.animationFrame = requestAnimationFrame(render);
        }
    }
    SLIDER.animationFrame = requestAnimationFrame(render);
  }

  function easeOutQuint(t, b, c, d) {
    t /= d;
    t--;
    return c * (t * t * t * t * t + 1) + b;
  }

  function startSlideshow() {
    mergeObjects(SLIDER, {
      autoTimeOut: setTimeout(function () {
        return slideTo(1);
      }, OPTIONS.slideInterval)
    });
  }

  function stopSlideshow() {
    cancelAnimationFrame(SLIDER.animationFrame);
    clearTimeout(SLIDER.autoTimeOut);
  }

  function shouldResumeSlideshow(autoSlide) {
    if (OPTIONS.slideShow && !OPTIONS.stopAfterInteraction || autoSlide) startSlideshow();
  }

  function setActiveDot(index) {
    if (SLIDER.dots) {
      var activeClass = CLASSES.dotActiveClass;
      removeClass(getElementChildren(SLIDER.dotContainer, '.' + activeClass), activeClass);
      addClass(SLIDER.dots[index], activeClass);
    }
  }

  function onWidthChange() {}
  // update slider width
  //stopSlideshow();
  //shouldResumeSlideshow();


  /*function touchInit() {
    let startPos,
      currPos,
      currentSlide;
     TouchEvents(SLIDER.container, {
      mouse: OPTIONS.mouseDrag,
      dragThreshold: OPTIONS.dragThreshold,
      // Pass touch state actions
      start: (event) => {
        stopSlideshow();
        startPos = getCurrentTranslate() / SLIDER.container.offsetWidth * 100;
        currentSlide = slideIndex % nrOfSlides;
        // Add drag class
        addClass(SLIDER.container, CLASSES.dragging);
      },
      move: (event, direction, diff) => {
        if (direction === 'left' || direction === 'right') {
          const horizontalDiff = diff.X / SLIDER.container.offsetWidth * 100;
          // Calculate changed position
          currPos = startPos + horizontalDiff;
           if (!OPTIONS.rewind) {
            flip(currPos, direction === 'left' ? 1 : -1);
          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {
            // Resist dragging if it's first slide
            // or last and if rewind is true
            currPos = startPos + (diff.X / 2.5);
          }
          setTranslate(SLIDER.container, currPos);
        }
      },
      end: (event, direction, diff) => {
        let targetSlide = slideIndex;
         // Only set new target slide if drag exceeds minimum drag distance
        if (Math.abs(diff.X) > OPTIONS.minimumDragDistance) {
          if (direction === 'left') {
            targetSlide = OPTIONS.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);
          } else if (direction === 'right') {
            targetSlide = OPTIONS.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);
          }
        }
        slideTo(targetSlide, false, OPTIONS.touchSpeed);
        // Remove drag class
        removeClass(SLIDER.container, CLASSES.dragging);
      }
    });
  }*/

  function getEventHandler(event, index) {
    var slideToIndex = function slideToIndex(index) {
      return slideTo(false, index);
    };
    var handler = {
      click: function click(e) {
        return slideToIndex(index);
      },
      focus: function focus(e) {
        stopSlideshow();
        _this.scrollLeft = 0;
        slideToIndex(index);
      }
    };
    return handler[event];
  }

  function setItemEventHandler(event, bubbles) {
    return function (item, index) {
      var listener = addEvent(item, event, getEventHandler(event, index), bubbles);
      return listener;
    };
  }

  function setupSlider(element, startIndex) {
    // Setup slide variables
    var container = getElementChildren(element, '.' + CLASSES.container);
    var slides = getItemsAsArray(getElementChildren(container, '.' + CLASSES.slide, true));
    var dotContainer = OPTIONS.dotContainer || getElementChildren(element, '.' + CLASSES.dotContainer);
    var dots = getItemsAsArray(getElementChildren(dotContainer, '.' + CLASSES.dotItem, true));
    var currentSlideIndex = startIndex;
    var lastSlideIndex = slides.length - 1;
    var isLastSlide = isLastItemIndex(lastSlideIndex);
    var slideData = setSlideData(container, slides, lastSlideIndex);
    var currentDistance = slideData[currentSlideIndex].distanceToThis;
    var transform = getSupportedProperty('transform');
    var setSlideFocusEvent = setItemEventHandler('focus', true);
    var setDotClickEvent = setItemEventHandler('click', false);
    var eventListeners = slides.map(setSlideFocusEvent).concat(dots.map(setDotClickEvent));

    // Bail if only one slide OR if transform is not supported
    if (!lastSlideIndex || !transform) return;

    // Merge variables into SLIDER
    mergeObjects(SLIDER, {
      container: container,
      slides: slides,
      dotContainer: dotContainer,
      dots: dots,
      slideData: slideData,
      transform: transform,
      currentSlideIndex: currentSlideIndex,
      lastSlideIndex: lastSlideIndex,
      isLastSlide: isLastSlide,
      currentDistance: currentDistance,
      eventListeners: eventListeners
    });

    // Set position and active dot
    setTranslate(container, currentDistance);
    setActiveDot(currentSlideIndex);

    // Conditional actions
    //if (OPTIONS.infinite) setItemInfinitePosition(currentSlideIndex, lastSlideIndex, slideData);

    if (OPTIONS.mouseDrag) addClass(container, CLASSES.mouseDrag);
    if (OPTIONS.slideShow) startSlideshow();

    // REMOVE
    setBoundData();

    if (OPTIONS.onSetup) setTimeout(function () {
      return OPTIONS.onSetup(SLIDER);
    }, 0);
  }

  // Init
  //setupSlider(_this, OPTIONS.startSlide);


  // Expose slider API
  return {
    next: function next() {
      return slideTo(1);
    },
    prev: function prev() {
      return slideTo(-1);
    },
    stop: stopSlideshow,
    start: startSlideshow,
    init: function init(startSlideIndex) {
      // killSlider();
      setupSlider(_this, startSlideIndex || OPTIONS.startSlide);
    }
    //kill: killSlider,
    //moveTo: (slideNr, speed) => slideTo(slideNr, true, speed)
  };
}
'use strict';

(function () {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  if (!window.requestAnimationFrame) window.requestAnimationFrame = function (callback, element) {
    var currTime = new Date().getTime();
    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    var id = window.setTimeout(function () {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };

  if (!window.cancelAnimationFrame) window.cancelAnimationFrame = function (id) {
    clearTimeout(id);
  };
})();
'use strict';

/*!
 * Event Burrito is a touch / mouse / pointer event unifier
 * https://github.com/wilddeer/Event-Burrito
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 *
 * NOTE: Event Burrito has been modified from
 * its original form to suit this project.
 */

/* exported TouchEvents */
function TouchEvents(_this, options) {
  'use strict';

  var touchStateCallback = function touchStateCallback() {},
      o = {
    preventDefault: true,
    clicksAllowed: true,
    mouse: true,
    dragThreshold: 10, // Minimum distance to determine swipe direction
    start: touchStateCallback,
    move: touchStateCallback,
    end: touchStateCallback
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  var start = {},
      diff = {},
      direction = void 0,
      eventType = void 0,
      axis = void 0,
      support = {
    pointerEvents: !!window.navigator.pointerEnabled,
    msPointerEvents: !!window.navigator.msPointerEnabled
  },
      eventModel = support.pointerEvents ? 1 : support.msPointerEvents ? 2 : 0,
      events = [['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events
  ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events
  ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events
  ['mousedown', 'mousemove', 'mouseup', false] //mouse events
  ],
      checks = [
  //touch events
  function (e) {
    //skip the event if it's multitouch or pinch move
    return e.touches && e.touches.length > 1 || e.scale && e.scale !== 1;
  },
  //pointer events
  function (e) {
    //Skip it, if:
    //1. event is not primary (other pointers during multitouch),
    //2. left mouse button is not pressed,
    //3. mouse drag is disabled and event is not touch
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen';
  },
  //IE10 pointer events
  function (e) {
    //same checks as in pointer events
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN;
  },
  //mouse events
  function (e) {
    //skip the event if left mouse button is not pressed
    //in IE7-8 `buttons` is not defined, in IE9 LMB is 0
    return e.buttons && e.buttons !== 1;
  }];

  function mergeObjects(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    if (!event) return;
    el.addEventListener(event, func, !!bool);
  }

  function removeEvent(el, event, func, bool) {
    if (!event) return;
    el.removeEventListener(event, func, !!bool);
  }

  function preventDefault(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
  }

  function getDiff(event) {
    diff = {
      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,
      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,
      time: new Date().getTime() - start.time
    };
  }

  function touchStart(event, type) {
    direction = '';
    o.clicksAllowed = true;
    eventType = type;

    if (checks[eventType](event)) return;
    if (preventDefault && eventType) preventDefault(event);

    addEvent(document, events[eventType][1], touchMove);
    addEvent(document, events[eventType][2], touchEnd);
    addEvent(document, events[eventType][3], touchEnd);

    start = {
      X: eventType ? event.clientX : event.touches[0].clientX,
      Y: eventType ? event.clientY : event.touches[0].clientY,
      time: new Date().getTime()
    };

    for (var key in diff) {
      diff[key] = 0;
    }
    o.start(event);
  }

  function touchMove(event) {
    getDiff(event);

    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.
    document['on' + events[eventType][1]] = function (e) {
      preventDefault(e);
    };

    if (!axis) {
      axis = o.dragThreshold < Math.abs(diff.X) ? 'X' : o.dragThreshold < Math.abs(diff.Y) ? 'Y' : false;
    } else {
      if (axis === 'X') {
        direction = diff.X < 0 ? 'left' : 'right';
        preventDefault && preventDefault(event);
      } else if (axis === 'Y') {
        direction = diff.Y < 0 ? 'up' : 'down';
      }
    }

    o.move(event, direction, diff);
  }

  function touchEnd(event) {
    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();

    removeEvent(document, events[eventType][1], touchMove);
    removeEvent(document, events[eventType][2], touchEnd);
    removeEvent(document, events[eventType][3], touchEnd);

    //Enable document scrolling
    document['on' + events[eventType][1]] = function (e) {
      return true;
    };

    o.end(event, direction, diff);
    axis = false;
  }

  function init() {
    // Bind touchstart
    addEvent(_this, events[eventModel][0], function (event) {
      touchStart(event, eventModel);
    });
    // Prevent stuff from dragging when using mouse
    addEvent(_this, 'dragstart', preventDefault);

    // Bind mousedown if necessary
    if (o.mouse && !eventModel) {
      addEvent(_this, events[3][0], function (event) {
        touchStart(event, 3);
      });
    }

    // No clicking during touch
    addEvent(_this, 'click', function (event) {
      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);
    });
  }

  // Init touch listeners
  init();
}
//# sourceMappingURL=hammerslider.min.js.map
