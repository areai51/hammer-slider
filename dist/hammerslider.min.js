'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function HammerSlider(_this, options) {
  'use strict';

  // Main declarations

  var SLIDER = {
    contentWidth: undefined,
    container: undefined,
    slides: undefined,
    dotContainer: undefined,
    dots: undefined,
    slideData: undefined,
    transform: undefined,
    currentSlideIndex: undefined,
    lastSlideIndex: undefined,
    isLastSlide: undefined,
    currentDistance: undefined,
    eventListeners: undefined
  };

  // Default options
  var OPTIONS = {
    slideShow: false,
    slideInterval: 5000,
    slideSpeed: 1200,
    //touchSpeed: 800,
    startSlide: 0,
    alignSlides: 'center',
    dragThreshold: 10,
    minimumDragDistance: 30,
    stopAfterInteraction: true,
    infinite: true,
    mouseDrag: false,
    dotContainer: undefined,
    beforeSlideChange: undefined,
    afterSlideChange: undefined,
    onSetup: undefined,
    classPrefix: 'c-slider'
  };

  // Merge user options into defaults
  options && mergeObjects(OPTIONS, options);

  // Class names
  var CLASSES = {
    container: OPTIONS.classPrefix + '__container',
    slide: OPTIONS.classPrefix + '__slide',
    dotContainer: OPTIONS.classPrefix + '__dots',
    dotItem: OPTIONS.classPrefix + '__dot',
    dotActiveClass: OPTIONS.classPrefix + '__dot--is-active',
    dragging: OPTIONS.classPrefix + '__container--is-dragging',
    mouseDrag: OPTIONS.classPrefix + '__container--mouse-drag-enabled'
  };

  // Change to Object.assign()
  function mergeObjects(target, source) {
    for (var key in source) {
      if (source.hasOwnProperty(key)) {
        target[key] = source[key];
      }
    }
    return target;
  }

  function getElementChildren(element, selector, all) {
    return element && element['querySelector' + (all ? 'All' : '')](selector);
  }

  function addEvent(element, event, func, bool) {
    element.addEventListener(event, func, !!bool);
    return { remove: function remove() {
        return element.removeEventListener(event, func, !!bool);
      } };
  }

  function addClass(element, className) {
    if (element) element.classList.add(className);
  }

  function removeClass(element, className) {
    if (element) element.classList.remove(className);
  }

  function forEachItem(array, callback, startIndex) {
    for (var index = startIndex || 0; index < array.length; index += 1) {
      var returnValue = callback(array[index], index, array);
      if (returnValue) return returnValue;
    }
    return false;
  }

  function getItemsAsArray(nodeList) {
    var returnArray = [];
    if (nodeList) forEachItem(nodeList, function (item) {
      returnArray.push(item);
    });
    return returnArray;
  }

  function getPercentageOfTotal(fraction, total) {
    return fraction / total * 100;
  }

  function getSupportedProperty(property) {
    var prefixes = ['', 'webkit', 'moz', 'ms', 'o'];
    var div = document.createElement('div');

    return forEachItem(prefixes, function (prefix) {
      var formattedProperty = '' + (prefix ? '-' + prefix + '-' : '') + property;
      if (typeof div.style[formattedProperty] !== 'undefined') return formattedProperty;
    });
  }

  function getTranslate(element) {
    var transform = window.getComputedStyle(element, null).getPropertyValue(SLIDER.transform);
    var transformType = transform.match('matrix3d') ? 12 : 4;
    var transformValue = parseFloat(transform.split(',')[transformType]);
    return getPercentageOfTotal(transformValue, element.offsetWidth);
  }

  function setTranslate(element, value, threeD) {
    var type = threeD ? '3d' : 'X';
    var translate = function translate(to) {
      return element.style[SLIDER.transform] = 'translate' + type + '(' + to + '%' + (threeD ? ',0,0' : '') + ')';
    };
    if (value !== false) translate(value);
    return translate;
  }

  /* ------ Item calculations ------ */

  function setItemWidth(containerWidth) {
    return function (item, index) {
      var width = Math.round(getPercentageOfTotal(item.element.offsetWidth, containerWidth));
      return mergeObjects(item, { width: width });
    };
  }

  function setItemAlignment(alignment) {
    var align = {
      left: function left() {
        return 0;
      },
      center: function center(width) {
        return (100 - width) / 2;
      },
      right: function right(width) {
        return 100 - width;
      }
    };
    return align[alignment] || align['center'];
  }

  function setItemAlignDistance(alignItem) {
    return function (item, index, itemArray) {
      var alignDistance = alignItem(item.width);
      return mergeObjects(item, { alignDistance: alignDistance });
    };
  }

  function setDistanceToItem() {
    return function (item, index, itemArray) {
      var distanceToThis = itemArray.reduce(function (accumulator, _ref, innerIndex) {
        var width = _ref.width;

        if (innerIndex > index) return accumulator;
        return accumulator + (innerIndex === index ? item.alignDistance : -width);
      }, 0);
      return mergeObjects(item, { distanceToThis: distanceToThis });
    };
  }

  function setDistanceBetweenItems(lastItemIndex) {
    return function (item, index, itemArray) {
      var nextItemIndex = !index ? lastItemIndex : index - 1;
      var distanceToNext = itemArray[nextItemIndex].distanceToThis - item.distanceToThis;
      return mergeObjects(item, { distanceToNext: distanceToNext });
    };
  }

  function setItemDistanceToFlip(lastItemIndex) {
    return function (item, index, itemArray) {
      var distanceToFlip = itemArray.reduce(function (accumulator, _ref2) {
        var width = _ref2.width;
        return accumulator + getPercentageOfTotal(width, item.width);
      }, 0);
      return mergeObjects(item, { distanceToFlip: distanceToFlip });
    };
  }

  function setItemPosition(item, position) {
    setTranslate(item.element, position);
    return mergeObjects(item, { position: position });
  }

  function getSlideData(container, items, lastItemIndex) {
    var setSlideWidth = setItemWidth(container.offsetWidth);
    var setSlideAlignDistance = setItemAlignDistance(setItemAlignment(OPTIONS.alignSlides));
    var setDistanceToSlide = setDistanceToItem();
    var setDistanceBetweenSlides = setDistanceBetweenItems(lastItemIndex);
    var setSlideDistanceToFlip = setItemDistanceToFlip(lastItemIndex);

    var slideData = [].concat(_toConsumableArray(items)).map(function (element) {
      return { element: element };
    }).map(setSlideWidth).map(setSlideAlignDistance).map(setDistanceToSlide).map(setDistanceBetweenSlides).map(setSlideDistanceToFlip);

    // Infinite sliding specific calculations - Move to separate func
    if (OPTIONS.infinite) {
      SLIDER.contentWidth = slideData.reduce(function (accumulator, _ref3) {
        var width = _ref3.width;
        return accumulator + width;
      }, 0);
      slideData[0].distanceToNext += SLIDER.contentWidth;
    }
    return slideData;
  }

  /* ------ Flip calculations ------ */

  function getItemsInView() {
    var gapToFirstSlide = SLIDER.slideData[0].distanceToThis;
    var leftGapWidth = gapToFirstSlide + 1;
    var rightGapWidth = 100 - leftGapWidth + 2;
    var itemsToLeft = getItemsInFraction(leftGapWidth, -1, 0);
    var itemsToRight = getItemsInFraction(rightGapWidth + 20, 1, SLIDER.lastSlideIndex);

    var checks = [function () {
      return OPTIONS.alignSlides === 'center';
    }, function () {
      return SLIDER.slideData[SLIDER.lastSlideIndex].width < 55;
    }, function () {
      return leftGapWidth < SLIDER.slideData[SLIDER.lastSlideIndex].width;
    }, function () {
      return SLIDER.lastSlideIndex > 2;
    }];

    var didNotPassChecks = forEachItem(checks, function (check) {
      return !check() && 1;
    });
    /*
      if (didNotPassChecks) {
        rightGapWidth + 20
      }
    */

    return {
      items: itemsToLeft.concat(itemsToRight),
      itemsToLeft: itemsToLeft,
      itemsToRight: itemsToRight
    };
  }

  function getItemsInFraction(fraction, direction, itemIndex) {
    var items = [];
    var accumulator = 0;

    return forEachItem(SLIDER.slideData, function (item, index, itemArray) {
      if (accumulator >= fraction) return items;
      itemIndex = getNextItemIndex(itemIndex, direction);
      accumulator += itemArray[itemIndex].width;
      items.push(itemIndex);
    });
  }

  function positionItemsInView(direction) {
    var isItemToRight = false;
    var getSlidePosition = getItemPosition()[direction];

    SLIDER.flipData.items.forEach(function (itemIndex) {
      if (!itemIndex) isItemToRight = true;
      var item = SLIDER.slideData[itemIndex];
      setItemPosition(item, getSlidePosition(item, isItemToRight));
    });
  }

  function getInitialFlipIndex(items, direction) {
    var intersectIndex = items[items.length - 2] || 0;
    var flipIndex = getNextItemIndex(intersectIndex, direction);
    return { intersectIndex: intersectIndex, flipIndex: flipIndex };
  }

  function getItemPosition() {
    return {
      '1': function _(item, isItemToRight) {
        return isItemToRight ? 0 : item.distanceToFlip * -1;
      },
      '-1': function _(item, isItemToRight) {
        return isItemToRight ? item.distanceToFlip : 0;
      }
    };
  }

  function resetFlipIndex(flipData) {
    return {
      '1': getInitialFlipIndex(flipData.itemsToLeft, -1),
      '-1': getInitialFlipIndex(flipData.itemsToRight, 1)
    };
  }

  function getSlidableDistance(contentWidth, distance) {
    return {
      '1': -contentWidth + distance + 1,
      '-1': distance - 1
    };
  }

  function hasReachedDistance(position) {
    return {
      '1': function _(distance) {
        return position < distance;
      },
      '-1': function _(distance) {
        return position > distance;
      }
    };
  }

  function setFlipData() {
    var flipData = getItemsInView();
    var slideableDistance = getSlidableDistance(SLIDER.contentWidth, SLIDER.slideData[0].alignDistance);
    mergeObjects(flipData, resetFlipIndex(flipData));
    mergeObjects(flipData, {
      slideableDistance: slideableDistance
    });

    SLIDER.flipData = flipData;
    positionItemsInView(1);
  }

  function getIntersectPoint(itemArray, direction) {
    var intersect = {
      '1': function _(item) {
        return item.distanceToThis - item.alignDistance - 1;
      },
      '-1': function _(item) {
        return item.distanceToThis - item.alignDistance + (100 - item.width + 1);
      }
    };
    return function (flipIndex, intersectItem) {
      if (itemArray.indexOf(flipIndex) < 0) return;
      var intersectPoint = intersect[direction](intersectItem);
      var position = intersectItem.position;
      return !position ? intersectPoint : intersectPoint + SLIDER.contentWidth * (position < 0 ? 1 : -1);
    };
  }

  /* DO HUGE REFACTOR BELOW */
  function flip(position, direction) {
    var slideData = SLIDER.slideData;
    var flipData = SLIDER.flipData;
    var currentFlip = flipData[direction];
    var oppositeFlip = flipData[direction * -1];
    var slideableDistance = flipData.slideableDistance[direction];
    var hasReachedPoint = hasReachedDistance(position)[direction];
    var intersect = getIntersectPoint(flipData.items, direction);
    var intersectPoint = intersect(currentFlip.flipIndex, slideData[currentFlip.intersectIndex]);

    if (hasReachedPoint(slideableDistance)) {
      mergeObjects(flipData, resetFlipIndex(flipData));
      positionItemsInView(direction);
      return true;
    }

    if (intersectPoint && hasReachedPoint(intersectPoint)) {
      var flipItem = slideData[currentFlip.flipIndex];
      var itemPosition = flipItem.position + flipItem.distanceToFlip * direction;
      setItemPosition(flipItem, itemPosition);

      mergeObjects(oppositeFlip, {
        intersectIndex: getNextItemIndex(oppositeFlip.intersectIndex, direction),
        flipIndex: currentFlip.flipIndex
      });

      mergeObjects(currentFlip, {
        intersectIndex: getNextItemIndex(currentFlip.intersectIndex, direction),
        flipIndex: getNextItemIndex(currentFlip.flipIndex, direction)
      });
    }
    return false;
  }
  /* DO HUGE REFACTOR ABOVE */

  function isLastItemIndex(lastIndex) {
    return function (index) {
      return index === lastIndex;
    };
  }

  function getNextItemIndex(currentItemIndex, direction) {
    if (direction === 1) {
      if (SLIDER.isLastSlide(currentItemIndex)) return 0;
    } else if (!currentItemIndex) {
      return SLIDER.lastSlideIndex;
    }
    return currentItemIndex + direction;
  }

  function slideTo(direction, jumpTo) {
    /* Clean this mess up */
    stopSlideshow();
    var currentSlideIndex = direction ? getNextItemIndex(SLIDER.currentSlideIndex, direction) : jumpTo;
    var currentDistance = void 0;

    if (direction) {
      var index = direction === 1 ? currentSlideIndex : getNextItemIndex(currentSlideIndex, 1);
      currentDistance = SLIDER.currentDistance - SLIDER.slideData[index].distanceToNext * direction;
    } else {
      /*
      if ((!SLIDER.currentSlideIndex && SLIDER.isLastSlide(jumpTo)) || (SLIDER.isLastSlide(SLIDER.currentSlideIndex) && !jumpTo)) {
        slideTo(slideDirection * -1);
        return;
      }
      */
      currentDistance = SLIDER.slideData[jumpTo].distanceToThis;
    }

    mergeObjects(SLIDER, { currentSlideIndex: currentSlideIndex, currentDistance: currentDistance });
    if (OPTIONS.beforeSlideChange) OPTIONS.beforeSlideChange(currentSlideIndex);

    setActiveDot(currentSlideIndex);
    animate(currentDistance);
  }

  function animate(slideDistance) {
    /* Clean this mess up */
    var translate = setTranslate(SLIDER.container, false, true);
    var slideSpeed = OPTIONS.slideSpeed;
    var increment = 20;

    var currPos = getTranslate(SLIDER.container);
    var currentTime = 0;
    var start = currPos;
    var change = slideDistance - start;

    var direction = slideDistance < currPos ? 1 : -1;

    function render() {
      // Sliding ended
      if (currentTime > slideSpeed) {}
      //shouldResumeSlideshow(autoSlide);
      //OPTIONS.afterSlideChange && OPTIONS.afterSlideChange();

      // Else
      else {
          if (OPTIONS.infinite && flip(currPos, direction)) {
            SLIDER.currentDistance += SLIDER.contentWidth * direction;
            start += SLIDER.contentWidth * direction;
          }
          currPos = easeOutQuint(currentTime, start, change, slideSpeed);
          currentTime += increment;
          translate(currPos);
          SLIDER.animationFrame = requestAnimationFrame(render);
        }
    }
    SLIDER.animationFrame = requestAnimationFrame(render);
  }

  function easeOutQuint(t, b, c, d) {
    t /= d;
    t--;
    return c * (t * t * t * t * t + 1) + b;
  }

  function startSlideshow() {
    mergeObjects(SLIDER, {
      autoTimeOut: setTimeout(function () {
        return slideTo(1);
      }, OPTIONS.slideInterval)
    });
  }

  function stopSlideshow() {
    cancelAnimationFrame(SLIDER.animationFrame);
    clearTimeout(SLIDER.autoTimeOut);
  }

  function shouldResumeSlideshow(autoSlide) {
    if (OPTIONS.slideShow && !OPTIONS.stopAfterInteraction || autoSlide) startSlideshow();
  }

  function setActiveDot(index) {
    if (SLIDER.dots) {
      var activeClass = CLASSES.dotActiveClass;
      removeClass(getElementChildren(SLIDER.dotContainer, '.' + activeClass), activeClass);
      addClass(SLIDER.dots[index], activeClass);
    }
  }

  function onWidthChange() {}
  // update slider width
  //stopSlideshow();
  //shouldResumeSlideshow();


  /*function touchInit() {
    let startPos,
      currPos,
      currentSlide;
     TouchEvents(SLIDER.container, {
      mouse: OPTIONS.mouseDrag,
      dragThreshold: OPTIONS.dragThreshold,
      // Pass touch state actions
      start: (event) => {
        stopSlideshow();
        startPos = getTranslate() / SLIDER.container.offsetWidth * 100;
        currentSlide = slideIndex % nrOfSlides;
        // Add drag class
        addClass(SLIDER.container, CLASSES.dragging);
      },
      move: (event, direction, diff) => {
        if (direction === 'left' || direction === 'right') {
          const horizontalDiff = diff.X / SLIDER.container.offsetWidth * 100;
          // Calculate changed position
          currPos = startPos + horizontalDiff;
           if (!OPTIONS.rewind) {
            flip(currPos, direction === 'left' ? 1 : -1);
          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {
            // Resist dragging if it's first slide
            // or last and if rewind is true
            currPos = startPos + (diff.X / 2.5);
          }
          setTranslate(SLIDER.container, currPos);
        }
      },
      end: (event, direction, diff) => {
        let targetSlide = slideIndex;
         // Only set new target slide if drag exceeds minimum drag distance
        if (Math.abs(diff.X) > OPTIONS.minimumDragDistance) {
          if (direction === 'left') {
            targetSlide = OPTIONS.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);
          } else if (direction === 'right') {
            targetSlide = OPTIONS.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);
          }
        }
        slideTo(targetSlide, false, OPTIONS.touchSpeed);
        // Remove drag class
        removeClass(SLIDER.container, CLASSES.dragging);
      }
    });
  }*/

  function getEventHandler(event, index) {
    var slideToIndex = function slideToIndex(index) {
      return slideTo(false, index);
    };
    var handler = {
      click: function click(e) {
        return slideToIndex(index);
      },
      focus: function focus(e) {
        stopSlideshow();
        _this.scrollLeft = 0;
        slideToIndex(index);
      }
    };
    return handler[event];
  }

  function setItemEventHandler(event, bubbles) {
    return function (item, index) {
      var listener = addEvent(item, event, getEventHandler(event, index), bubbles);
      return listener;
    };
  }

  function setupSlider(element, startIndex) {
    // Setup slide variables
    var container = getElementChildren(element, '.' + CLASSES.container);
    var slides = getItemsAsArray(getElementChildren(container, '.' + CLASSES.slide, true));
    var dotContainer = OPTIONS.dotContainer || getElementChildren(element, '.' + CLASSES.dotContainer);
    var dots = getItemsAsArray(getElementChildren(dotContainer, '.' + CLASSES.dotItem, true));
    var currentSlideIndex = startIndex;
    var lastSlideIndex = slides.length - 1;
    var isLastSlide = isLastItemIndex(lastSlideIndex);
    var slideData = getSlideData(container, slides, lastSlideIndex);
    var currentDistance = slideData[currentSlideIndex].distanceToThis;
    var transform = getSupportedProperty('transform');
    var setSlideFocusEvent = setItemEventHandler('focus', true);
    var setDotClickEvent = setItemEventHandler('click', false);
    var eventListeners = slides.map(setSlideFocusEvent).concat(dots.map(setDotClickEvent));

    // Bail if only one slide OR if transform is not supported
    if (!lastSlideIndex || !transform) return;

    // Merge variables into SLIDER
    mergeObjects(SLIDER, {
      container: container,
      slides: slides,
      dotContainer: dotContainer,
      dots: dots,
      slideData: slideData,
      transform: transform,
      currentSlideIndex: currentSlideIndex,
      lastSlideIndex: lastSlideIndex,
      isLastSlide: isLastSlide,
      currentDistance: currentDistance,
      eventListeners: eventListeners
    });

    // Set position and active dot
    setTranslate(container, currentDistance);
    setActiveDot(currentSlideIndex);

    // Conditional actions
    //if (OPTIONS.infinite) setItemInfinitePosition(currentSlideIndex, lastSlideIndex, slideData);

    if (OPTIONS.mouseDrag) addClass(container, CLASSES.mouseDrag);
    if (OPTIONS.slideShow) startSlideshow();

    // REMOVE
    setFlipData();

    if (OPTIONS.onSetup) setTimeout(function () {
      return OPTIONS.onSetup(SLIDER);
    }, 0);
  }

  // Init
  //setupSlider(_this, OPTIONS.startSlide);


  // Expose slider API
  return {
    next: function next() {
      return slideTo(1);
    },
    prev: function prev() {
      return slideTo(-1);
    },
    stop: stopSlideshow,
    start: startSlideshow,
    init: function init(startSlideIndex) {
      // killSlider();
      setupSlider(_this, startSlideIndex || OPTIONS.startSlide);
    }
    //kill: killSlider,
    //moveTo: (slideNr, speed) => slideTo(slideNr, true, speed)
  };
}
'use strict';

/*!
 * Event Burrito is a touch / mouse / pointer event unifier
 * https://github.com/wilddeer/Event-Burrito
 * Copyright Oleg Korsunsky | http://wd.dizaina.net/
 *
 * MIT License
 *
 * NOTE: Event Burrito has been modified from
 * its original form to suit this project.
 */

/* exported TouchEvents */
function TouchEvents(_this, options) {
  'use strict';

  var touchStateCallback = function touchStateCallback() {},
      o = {
    preventDefault: true,
    clicksAllowed: true,
    mouse: true,
    dragThreshold: 10, // Minimum distance to determine swipe direction
    start: touchStateCallback,
    move: touchStateCallback,
    end: touchStateCallback
  };

  // Merge user options into defaults
  options && mergeObjects(o, options);

  var start = {},
      diff = {},
      direction = void 0,
      eventType = void 0,
      axis = void 0,
      support = {
    pointerEvents: !!window.navigator.pointerEnabled,
    msPointerEvents: !!window.navigator.msPointerEnabled
  },
      eventModel = support.pointerEvents ? 1 : support.msPointerEvents ? 2 : 0,
      events = [['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events
  ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events
  ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events
  ['mousedown', 'mousemove', 'mouseup', false] //mouse events
  ],
      checks = [
  //touch events
  function (e) {
    //skip the event if it's multitouch or pinch move
    return e.touches && e.touches.length > 1 || e.scale && e.scale !== 1;
  },
  //pointer events
  function (e) {
    //Skip it, if:
    //1. event is not primary (other pointers during multitouch),
    //2. left mouse button is not pressed,
    //3. mouse drag is disabled and event is not touch
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen';
  },
  //IE10 pointer events
  function (e) {
    //same checks as in pointer events
    return !e.isPrimary || e.buttons && e.buttons !== 1 || !o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN;
  },
  //mouse events
  function (e) {
    //skip the event if left mouse button is not pressed
    //in IE7-8 `buttons` is not defined, in IE9 LMB is 0
    return e.buttons && e.buttons !== 1;
  }];

  function mergeObjects(targetObj, sourceObject) {
    for (var key in sourceObject) {
      if (sourceObject.hasOwnProperty(key)) {
        targetObj[key] = sourceObject[key];
      }
    }
  }

  function addEvent(el, event, func, bool) {
    if (!event) return;
    el.addEventListener(event, func, !!bool);
  }

  function removeEvent(el, event, func, bool) {
    if (!event) return;
    el.removeEventListener(event, func, !!bool);
  }

  function preventDefault(event) {
    event.preventDefault ? event.preventDefault() : event.returnValue = false;
  }

  function getDiff(event) {
    diff = {
      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,
      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,
      time: new Date().getTime() - start.time
    };
  }

  function touchStart(event, type) {
    direction = '';
    o.clicksAllowed = true;
    eventType = type;

    if (checks[eventType](event)) return;
    if (preventDefault && eventType) preventDefault(event);

    addEvent(document, events[eventType][1], touchMove);
    addEvent(document, events[eventType][2], touchEnd);
    addEvent(document, events[eventType][3], touchEnd);

    start = {
      X: eventType ? event.clientX : event.touches[0].clientX,
      Y: eventType ? event.clientY : event.touches[0].clientY,
      time: new Date().getTime()
    };

    for (var key in diff) {
      diff[key] = 0;
    }
    o.start(event);
  }

  function touchMove(event) {
    getDiff(event);

    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.
    document['on' + events[eventType][1]] = function (e) {
      preventDefault(e);
    };

    if (!axis) {
      axis = o.dragThreshold < Math.abs(diff.X) ? 'X' : o.dragThreshold < Math.abs(diff.Y) ? 'Y' : false;
    } else {
      if (axis === 'X') {
        direction = diff.X < 0 ? 'left' : 'right';
        preventDefault && preventDefault(event);
      } else if (axis === 'Y') {
        direction = diff.Y < 0 ? 'up' : 'down';
      }
    }

    o.move(event, direction, diff);
  }

  function touchEnd(event) {
    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();

    removeEvent(document, events[eventType][1], touchMove);
    removeEvent(document, events[eventType][2], touchEnd);
    removeEvent(document, events[eventType][3], touchEnd);

    //Enable document scrolling
    document['on' + events[eventType][1]] = function (e) {
      return true;
    };

    o.end(event, direction, diff);
    axis = false;
  }

  function init() {
    // Bind touchstart
    addEvent(_this, events[eventModel][0], function (event) {
      touchStart(event, eventModel);
    });
    // Prevent stuff from dragging when using mouse
    addEvent(_this, 'dragstart', preventDefault);

    // Bind mousedown if necessary
    if (o.mouse && !eventModel) {
      addEvent(_this, events[3][0], function (event) {
        touchStart(event, 3);
      });
    }

    // No clicking during touch
    addEvent(_this, 'click', function (event) {
      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);
    });
  }

  // Init touch listeners
  init();
}
//# sourceMappingURL=hammerslider.min.js.map
