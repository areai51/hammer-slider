{"version":3,"sources":["hammerslider.js","touch-events.js"],"names":["HammerSlider","_this","options","SLIDER","container","undefined","slides","dotContainer","dots","contentWidth","currentSlideIndex","lastSlideIndex","isLastSlide","slideData","currentDistance","transform","eventListeners","OPTIONS","slideShow","slideInterval","slideSpeed","startSlide","alignSlides","dragThreshold","minimumDragDistance","stopAfterInteraction","infinite","mouseDrag","beforeSlideChange","afterSlideChange","onSetup","classPrefix","mergeObjects","CLASSES","slide","dotItem","dotActiveClass","dragging","target","source","key","hasOwnProperty","getElementChildren","element","selector","all","addEvent","event","func","bool","addEventListener","remove","removeEventListener","addClass","className","classList","add","removeClass","forEachItem","array","callback","startIndex","index","length","returnValue","getItemsAsArray","nodeList","returnArray","item","push","getPercentageOfTotal","fraction","total","getSupportedProperty","property","prefixes","div","document","createElement","prefix","formattedProperty","style","getTranslate","window","getComputedStyle","getPropertyValue","transformType","match","transformValue","parseFloat","split","offsetWidth","setTranslate","value","threeD","type","translate","to","getContentWidth","items","reduce","accumulator","setItemWidth","containerWidth","width","Math","round","setItemAlignment","alignment","align","left","center","right","setItemAlignDistance","alignItem","itemArray","alignDistance","setDistanceToItem","distanceToThis","innerIndex","setDistanceBetweenItems","lastItemIndex","infiniteDistance","nextItem","distanceToNext","setItemDistanceToFlip","distanceToFlip","setItemPosition","position","getSlideData","setSlideWidth","setSlideAlignDistance","setDistanceToSlide","setDistanceBetweenSlides","setSlideDistanceToFlip","map","getFlipItems","gapToFirstSlide","leftGapWidth","rightGapWidth","toLeft","getItemsInFraction","toRight","diff","abs","leftGap","lastGap","concat","direction","itemIndex","getNextItemIndex","positionFlipItems","isItemToRight","getSlidePosition","getFlipItemPosition","flipData","forEach","getInitialFlip","intersectIndex","flipIndex","getFlipReset","getFlipDistance","getSlidableDistance","distance","hasReachedDistance","setFlipData","state","slideableDistance","getFlipPoint","intersectItem","indexOf","flipPoint","flip","currentFlip","oppositeFlip","hasReached","setFlipPoint","flipItem","itemPosition","isLastItemIndex","lastIndex","currentItemIndex","slideTo","jumpTo","stopSlideshow","setActiveDot","animate","slideDistance","increment","currPos","currentTime","start","change","render","easeOutQuint","animationFrame","requestAnimationFrame","t","b","c","d","startSlideshow","autoTimeOut","setTimeout","cancelAnimationFrame","clearTimeout","shouldResumeSlideshow","autoSlide","activeClass","onWidthChange","getEventHandler","slideToIndex","handler","click","focus","e","scrollLeft","setItemEventHandler","bubbles","listener","setupSlider","setSlideFocusEvent","setDotClickEvent","next","prev","stop","init","startSlideIndex","TouchEvents","touchStateCallback","o","preventDefault","clicksAllowed","mouse","move","end","eventType","axis","support","pointerEvents","navigator","pointerEnabled","msPointerEvents","msPointerEnabled","eventModel","events","checks","touches","scale","isPrimary","buttons","pointerType","MSPOINTER_TYPE_TOUCH","MSPOINTER_TYPE_PEN","targetObj","sourceObject","el","removeEvent","getDiff","X","clientX","Y","clientY","time","Date","getTime","touchStart","touchMove","touchEnd","blur"],"mappings":"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","file":"hammerslider.min.js","sourcesContent":["function HammerSlider(_this, options) {\n  'use strict';\n\n  // Main declarations\n  const SLIDER = {\n    container: undefined,\n    slides: undefined,\n    dotContainer: undefined,\n    dots: undefined,\n    contentWidth: undefined,\n    currentSlideIndex: undefined,\n    lastSlideIndex: undefined,\n    isLastSlide: undefined,\n    slideData: undefined,\n    currentDistance: undefined,\n    transform: undefined,\n    eventListeners: undefined\n  };\n\n\n  // Default options\n  const OPTIONS = {\n    slideShow: false,\n    slideInterval: 5000,\n    slideSpeed: 1200,\n    //touchSpeed: 800,\n    startSlide: 0,\n    alignSlides: 'center',\n    dragThreshold: 10,\n    minimumDragDistance: 30,\n    stopAfterInteraction: true,\n    infinite: true,\n    mouseDrag: false,\n    dotContainer: undefined,\n    beforeSlideChange: undefined,\n    afterSlideChange: undefined,\n    onSetup: undefined,\n    classPrefix: 'c-slider'\n  };\n\n\n  // Merge user options into defaults\n  options && mergeObjects(OPTIONS, options);\n\n\n  // Class names\n  const CLASSES = {\n    container: `${OPTIONS.classPrefix}__container`,\n    slide: `${OPTIONS.classPrefix}__slide`,\n    dotContainer: `${OPTIONS.classPrefix}__dots`,\n    dotItem: `${OPTIONS.classPrefix}__dot`,\n    dotActiveClass: `${OPTIONS.classPrefix}__dot--is-active`,\n    dragging: `${OPTIONS.classPrefix}__container--is-dragging`,\n    mouseDrag: `${OPTIONS.classPrefix}__container--mouse-drag-enabled`\n  };\n\n\n  // Change to Object.assign()\n  function mergeObjects(target, source) {\n    for (let key in source) {\n      if (source.hasOwnProperty(key)) {\n        target[key] = source[key];\n      }\n    }\n    return target;\n  }\n\n\n  function getElementChildren(element, selector, all) {\n    return element && element[`querySelector${(all ? 'All' : '')}`](selector);\n  }\n\n\n  function addEvent(element, event, func, bool) {\n    element.addEventListener(event, func, !!bool);\n    return { remove: () => element.removeEventListener(event, func, !!bool) };\n  }\n\n\n  function addClass(element, className) {\n    if (element) element.classList.add(className);\n  }\n\n\n  function removeClass(element, className) {\n    if (element) element.classList.remove(className);\n  }\n\n\n  function forEachItem(array, callback, startIndex) {\n    for (let index = startIndex || 0; index < array.length; index += 1) {\n      const returnValue = callback(array[index], index, array);\n      if (returnValue) return returnValue;\n    }\n    return false;\n  }\n\n\n  function getItemsAsArray(nodeList) {\n    const returnArray = [];\n    if (nodeList) forEachItem(nodeList, (item) => { returnArray.push(item) });\n    return returnArray;\n  }\n\n\n  function getPercentageOfTotal(fraction, total) {\n    return fraction / total * 100;\n  }\n\n\n  function getSupportedProperty(property) {\n    const prefixes = ['', 'webkit', 'moz', 'ms', 'o'];\n    const div = document.createElement('div');\n\n    return forEachItem(prefixes, (prefix) => {\n      const formattedProperty = `${(prefix ? `-${prefix}-`: '')}${property}`;\n      if (typeof div.style[formattedProperty] !== 'undefined') return formattedProperty;\n    });\n  }\n\n\n  function getTranslate(element) {\n    const transform = window.getComputedStyle(element, null).getPropertyValue(SLIDER.transform);\n    const transformType = transform.match('matrix3d') ? 12 : 4;\n    const transformValue = parseFloat(transform.split(',')[transformType]);\n    return getPercentageOfTotal(transformValue, element.offsetWidth);\n  }\n\n\n  function setTranslate(element, value, threeD) {\n    const type = threeD ? '3d' : 'X';\n    const translate = to => element.style[SLIDER.transform] = `translate${type}(${to}%${threeD ? ',0,0' : ''})`;\n    if (value !== false) translate(value);\n    return translate;\n  }\n\n\n  function getContentWidth(container, items) {\n    return items.reduce((accumulator, {offsetWidth}) =>\n      accumulator + getPercentageOfTotal(offsetWidth, container.offsetWidth), 0);\n  }\n\n\n  /* ------ Item calculations ------ */\n\n  function setItemWidth(containerWidth) {\n    return (item, index) => {\n      const width = Math.round(getPercentageOfTotal(item.element.offsetWidth, containerWidth));\n      return mergeObjects(item, { width });\n    };\n  }\n\n\n  function setItemAlignment(alignment) {\n    const align = {\n      left: () => 0,\n      center: width => (100 - width) / 2,\n      right: width => 100 - width\n    };\n    return align[alignment] || align['center'];\n  }\n\n\n  function setItemAlignDistance(alignItem) {\n    return (item, index, itemArray) => {\n      const alignDistance = alignItem(item.width);\n      return mergeObjects(item, { alignDistance });\n    };\n  }\n\n\n  function setDistanceToItem() {\n    return (item, index, itemArray) => {\n      const distanceToThis = itemArray.reduce((accumulator, {width}, innerIndex) => {\n        if (innerIndex > index) return accumulator;\n        return accumulator + (innerIndex === index ? item.alignDistance : -width);\n      }, 0);\n      return mergeObjects(item, { distanceToThis });\n    };\n  }\n\n\n  function setDistanceBetweenItems(lastItemIndex, contentWidth) {\n    const infiniteDistance = index => OPTIONS.infinite && !index ? contentWidth : 0;\n    return (item, index, itemArray) => {\n      const nextItem = itemArray[(!index ? lastItemIndex : index - 1)];\n      const distanceToNext = nextItem.distanceToThis - item.distanceToThis + infiniteDistance(index);\n      return mergeObjects(item, { distanceToNext });\n    };\n  }\n\n\n  function setItemDistanceToFlip(contentWidth) {\n    return (item, index, itemArray) => {\n      const distanceToFlip = contentWidth / item.width * 100;\n      return mergeObjects(item, { distanceToFlip });\n    };\n  }\n\n\n  function setItemPosition(item, position) {\n    setTranslate(item.element, position);\n    return mergeObjects(item, { position });\n  }\n\n\n  function getSlideData(container, items, lastItemIndex, contentWidth) {\n    const setSlideWidth = setItemWidth(container.offsetWidth);\n    const setSlideAlignDistance = setItemAlignDistance(setItemAlignment(OPTIONS.alignSlides));\n    const setDistanceToSlide = setDistanceToItem();\n    const setDistanceBetweenSlides = setDistanceBetweenItems(lastItemIndex, contentWidth);\n    const setSlideDistanceToFlip = setItemDistanceToFlip(contentWidth);\n\n    return [...items]\n      .map(element => ({ element }))\n      .map(setSlideWidth)\n      .map(setSlideAlignDistance)\n      .map(setDistanceToSlide)\n      .map(setDistanceBetweenSlides)\n      .map(setSlideDistanceToFlip);\n  }\n\n\n  /* ------ Flip calculations ------ */\n\n  function getFlipItems() {\n    const gapToFirstSlide = SLIDER.slideData[0].distanceToThis;\n    const leftGapWidth = gapToFirstSlide + 1;\n    const rightGapWidth = 100 - leftGapWidth + 2;\n    let toLeft = getItemsInFraction(leftGapWidth, -1, 0);\n    let toRight = getItemsInFraction(rightGapWidth, 1, SLIDER.lastSlideIndex);\n\n    /* CLEAN UP BELOW */\n    const diff = SLIDER.slideData[toRight[toRight.length - 1]].width - SLIDER.slideData[toLeft[0]].width;\n\n    if (Math.abs(diff) > 0 && SLIDER.lastSlideIndex > 2) {\n      const leftGap = rightGapWidth - toRight.reduce((accumulator, item, index) => {\n        if (index === toRight.length - 1) return accumulator;\n        return accumulator += SLIDER.slideData[item].width;\n      }, 0);\n\n      const lastGap = SLIDER.slideData[toRight[toRight.length - 1]].width - leftGap;\n      toRight = getItemsInFraction((rightGapWidth + lastGap + 1), 1, SLIDER.lastSlideIndex);\n    }\n    /* CLEAN UP ABOVE */\n\n    return {\n      all: toLeft.concat(toRight),\n      toLeft,\n      toRight\n    };\n  }\n\n\n  function getItemsInFraction(fraction, direction, itemIndex) {\n    const items = [];\n    let accumulator = 0;\n\n    return forEachItem(SLIDER.slideData, (item, index, itemArray) => {\n      if (accumulator >= fraction) return items;\n      itemIndex = getNextItemIndex(itemIndex, direction);\n      accumulator += itemArray[itemIndex].width;\n      items.push(itemIndex);\n    });\n  }\n\n\n  function positionFlipItems(direction) {\n    let isItemToRight = false;\n    const getSlidePosition = getFlipItemPosition()[direction];\n\n    SLIDER.flipData.items.all.forEach((itemIndex) => {\n      if (!itemIndex) isItemToRight = true;\n      const item = SLIDER.slideData[itemIndex];\n      setItemPosition(item, getSlidePosition(item, isItemToRight));\n    });\n  }\n\n\n  function getInitialFlip(items, direction) {\n    const intersectIndex = items[items.length - 2] || 0;\n    const flipIndex = getNextItemIndex(intersectIndex, direction);\n    return { intersectIndex, flipIndex };\n  }\n\n\n  function getFlipItemPosition() {\n    return {\n      '1': (item, isItemToRight) => isItemToRight ? 0 : item.distanceToFlip * -1,\n      '-1': (item, isItemToRight) => isItemToRight ? item.distanceToFlip : 0\n    };\n  }\n\n\n  function getFlipReset(flipData) {\n    return {\n      '1': getInitialFlip(flipData.toLeft, -1),\n      '-1': getInitialFlip(flipData.toRight, 1)\n    };\n  }\n\n\n  function getFlipDistance() {\n    return {\n      '1': item => item.distanceToThis - item.alignDistance - 1,\n      '-1': item => item.distanceToThis - item.alignDistance + (100 - item.width + 1)\n    };\n  }\n\n\n  function getSlidableDistance(contentWidth, distance) {\n    return {\n      '1': -contentWidth + distance + 1,\n      '-1': distance - 1\n    };\n  }\n\n\n  function hasReachedDistance(position) {\n    return {\n      '1': distance => position < distance,\n      '-1': distance => position > distance\n    };\n  }\n\n\n  function setFlipData() {\n    const items = getFlipItems();\n    const state = getFlipReset(items);\n    const slideableDistance = getSlidableDistance(SLIDER.contentWidth, SLIDER.slideData[0].alignDistance);\n\n    const flipData = mergeObjects({}, {\n      slideableDistance,\n      items,\n      state\n    });\n\n    /* CHANGE BELOW TO RETURN */\n    SLIDER.flipData = flipData;\n    positionFlipItems(1);\n  }\n\n\n  function getFlipPoint(itemArray, direction) {\n    return (flipIndex, intersectItem) => {\n      if (itemArray.indexOf(flipIndex) < 0) return;\n      const flipPoint = getFlipDistance()[direction](intersectItem);\n      const position = intersectItem.position;\n      return !position ? flipPoint :\n        flipPoint + SLIDER.contentWidth * (position < 0 ? 1 : -1);\n    };\n  }\n\n\n  function flip(position, direction) {\n    const slideData = SLIDER.slideData;\n    const flipData = SLIDER.flipData;\n    const currentFlip = flipData.state[direction];\n    const oppositeFlip = flipData.state[direction * -1];\n    const slideableDistance = flipData.slideableDistance[direction];\n    const hasReached = hasReachedDistance(position)[direction];\n    const setFlipPoint = getFlipPoint(flipData.items.all, direction);\n    const flipPoint = setFlipPoint(currentFlip.flipIndex, slideData[currentFlip.intersectIndex]);\n\n    if (hasReached(slideableDistance)) {\n      mergeObjects(flipData.state, getFlipReset(flipData.items));\n      positionFlipItems(direction);\n      return true;\n    }\n\n    if (flipPoint && hasReached(flipPoint)) {\n      const flipItem = slideData[currentFlip.flipIndex];\n      const itemPosition = flipItem.position + (flipItem.distanceToFlip * direction);\n      setItemPosition(flipItem, itemPosition);\n\n      mergeObjects(oppositeFlip, {\n        intersectIndex: getNextItemIndex(oppositeFlip.intersectIndex, direction),\n        flipIndex: currentFlip.flipIndex\n      });\n\n      mergeObjects(currentFlip, {\n        intersectIndex: getNextItemIndex(currentFlip.intersectIndex, direction),\n        flipIndex: getNextItemIndex(currentFlip.flipIndex, direction)\n      });\n    }\n    return false;\n  }\n\n\n  function isLastItemIndex(lastIndex) {\n    return index => index === lastIndex;\n  }\n\n\n  function getNextItemIndex(currentItemIndex, direction) {\n    if (direction === 1) {\n      if (SLIDER.isLastSlide(currentItemIndex)) return 0;\n    } else if (!currentItemIndex) {\n      return SLIDER.lastSlideIndex;\n    }\n    return currentItemIndex + direction;\n  }\n\n\n  function slideTo(direction, jumpTo) {\n    /* Clean this mess up */\n    stopSlideshow();\n    const currentSlideIndex = direction ? getNextItemIndex(SLIDER.currentSlideIndex, direction) : jumpTo;\n    let currentDistance;\n\n    if (direction) {\n      const index = direction === 1 ? currentSlideIndex : getNextItemIndex(currentSlideIndex, 1);\n      currentDistance = SLIDER.currentDistance - SLIDER.slideData[index].distanceToNext * direction;\n    } else {\n      /*\n      if ((!SLIDER.currentSlideIndex && SLIDER.isLastSlide(jumpTo)) || (SLIDER.isLastSlide(SLIDER.currentSlideIndex) && !jumpTo)) {\n        slideTo(slideDirection * -1);\n        return;\n      }\n      */\n      currentDistance = SLIDER.slideData[jumpTo].distanceToThis;\n    }\n\n    mergeObjects(SLIDER, { currentSlideIndex, currentDistance });\n    if (OPTIONS.beforeSlideChange) OPTIONS.beforeSlideChange(currentSlideIndex);\n\n    setActiveDot(currentSlideIndex);\n    animate(currentDistance);\n  }\n\n\n  function animate(slideDistance) {\n    /* Clean this mess up */\n    const translate = setTranslate(SLIDER.container, false, true);\n    const slideSpeed = OPTIONS.slideSpeed;\n    const increment = 20;\n\n    let currPos = getTranslate(SLIDER.container);\n    let currentTime = 0;\n    let start = currPos;\n    let change = slideDistance - start;\n\n    const direction = slideDistance < currPos ? 1 : -1;\n\n    function render() {\n      // Sliding ended\n      if (currentTime > slideSpeed) {\n        //shouldResumeSlideshow(autoSlide);\n        //OPTIONS.afterSlideChange && OPTIONS.afterSlideChange();\n      }\n      // Else\n      else {\n        if (OPTIONS.infinite && flip(currPos, direction)) {\n          SLIDER.currentDistance += SLIDER.contentWidth * direction;\n          start += SLIDER.contentWidth * direction;\n        }\n        currPos = easeOutQuint(currentTime, start, change, slideSpeed);\n        currentTime += increment;\n        translate(currPos);\n        SLIDER.animationFrame = requestAnimationFrame(render);\n      }\n    }\n    SLIDER.animationFrame = requestAnimationFrame(render);\n  }\n\n\n  function easeOutQuint(t, b, c, d) {\n    t /= d;\n    t--;\n    return c * (t * t * t * t * t + 1) + b;\n  }\n\n\n  function startSlideshow() {\n    mergeObjects(SLIDER, {\n      autoTimeOut: setTimeout(() => slideTo(1), OPTIONS.slideInterval)\n    });\n  }\n\n\n  function stopSlideshow() {\n    cancelAnimationFrame(SLIDER.animationFrame);\n    clearTimeout(SLIDER.autoTimeOut);\n  }\n\n\n  function shouldResumeSlideshow(autoSlide) {\n    if ((OPTIONS.slideShow && !OPTIONS.stopAfterInteraction) || autoSlide) startSlideshow();\n  }\n\n\n  function setActiveDot(index) {\n    if (SLIDER.dots) {\n      const activeClass = CLASSES.dotActiveClass;\n      removeClass(getElementChildren(SLIDER.dotContainer, `.${activeClass}`), activeClass);\n      addClass(SLIDER.dots[index], activeClass);\n    }\n  }\n\n\n  function onWidthChange() {\n    // update slider width\n    //stopSlideshow();\n    //shouldResumeSlideshow();\n  }\n\n\n  /*function touchInit() {\n    let startPos,\n      currPos,\n      currentSlide;\n\n    TouchEvents(SLIDER.container, {\n      mouse: OPTIONS.mouseDrag,\n      dragThreshold: OPTIONS.dragThreshold,\n      // Pass touch state actions\n      start: (event) => {\n        stopSlideshow();\n        startPos = getTranslate() / SLIDER.container.offsetWidth * 100;\n        currentSlide = slideIndex % nrOfSlides;\n        // Add drag class\n        addClass(SLIDER.container, CLASSES.dragging);\n      },\n      move: (event, direction, diff) => {\n        if (direction === 'left' || direction === 'right') {\n          const horizontalDiff = diff.X / SLIDER.container.offsetWidth * 100;\n          // Calculate changed position\n          currPos = startPos + horizontalDiff;\n\n          if (!OPTIONS.rewind) {\n            flip(currPos, direction === 'left' ? 1 : -1);\n          } else if (!currentSlide && direction === 'right' || u.isLastSlide(currentSlide) && direction === 'left') {\n            // Resist dragging if it's first slide\n            // or last and if rewind is true\n            currPos = startPos + (diff.X / 2.5);\n          }\n          setTranslate(SLIDER.container, currPos);\n        }\n      },\n      end: (event, direction, diff) => {\n        let targetSlide = slideIndex;\n\n        // Only set new target slide if drag exceeds minimum drag distance\n        if (Math.abs(diff.X) > OPTIONS.minimumDragDistance) {\n          if (direction === 'left') {\n            targetSlide = OPTIONS.rewind && u.isLastSlide(currentSlide) ? u.lastSlide : u.getNextSlideNr(1);\n          } else if (direction === 'right') {\n            targetSlide = OPTIONS.rewind && !currentSlide ? 0 : u.getNextSlideNr(-1);\n          }\n        }\n        slideTo(targetSlide, false, OPTIONS.touchSpeed);\n        // Remove drag class\n        removeClass(SLIDER.container, CLASSES.dragging);\n      }\n    });\n  }*/\n\n\n  function getEventHandler(event, index) {\n    const slideToIndex = (index) => slideTo(false, index);\n    const handler = {\n      click: e => slideToIndex(index),\n      focus: (e) => {\n        stopSlideshow();\n        _this.scrollLeft = 0;\n        slideToIndex(index);\n      }\n    };\n    return handler[event];\n  }\n\n\n  function setItemEventHandler(event, bubbles) {\n    return (item, index) => {\n      const listener = addEvent(item, event, getEventHandler(event, index), bubbles);\n      return listener;\n    };\n  }\n\n\n  function setupSlider(element, startIndex) {\n    // Setup slide variables\n    const container = getElementChildren(element, `.${CLASSES.container}`);\n    const slides = getItemsAsArray(getElementChildren(container, `.${CLASSES.slide}`, true));\n    const dotContainer = OPTIONS.dotContainer || getElementChildren(element, `.${CLASSES.dotContainer}`);\n    const dots = getItemsAsArray(getElementChildren(dotContainer, `.${CLASSES.dotItem}`, true));\n    const contentWidth = getContentWidth(container, slides);\n    const currentSlideIndex = startIndex;\n    const lastSlideIndex = slides.length - 1;\n    const isLastSlide = isLastItemIndex(lastSlideIndex);\n    const slideData = getSlideData(container, slides, lastSlideIndex, contentWidth);\n    const currentDistance = slideData[currentSlideIndex].distanceToThis;\n    const transform = getSupportedProperty('transform');\n    const setSlideFocusEvent = setItemEventHandler('focus', true);\n    const setDotClickEvent = setItemEventHandler('click', false);\n    const eventListeners = slides.map(setSlideFocusEvent).concat(dots.map(setDotClickEvent));\n\n    // Bail if only one slide OR if transform is not supported\n    if (!lastSlideIndex || !transform) return;\n\n    // Merge variables into SLIDER\n    mergeObjects(SLIDER, {\n      container,\n      slides,\n      dotContainer,\n      dots,\n      contentWidth,\n      currentSlideIndex,\n      lastSlideIndex,\n      isLastSlide,\n      slideData,\n      currentDistance,\n      transform,\n      eventListeners\n    });\n\n    // Set position and active dot\n    setTranslate(container, currentDistance);\n    setActiveDot(currentSlideIndex);\n\n    // Conditional actions\n    //if (OPTIONS.infinite) setItemInfinitePosition(currentSlideIndex, lastSlideIndex, slideData);\n\n    if (OPTIONS.mouseDrag) addClass(container, CLASSES.mouseDrag);\n    if (OPTIONS.slideShow) startSlideshow();\n\n    // REMOVE\n    setFlipData();\n\n    if (OPTIONS.onSetup) setTimeout(() => OPTIONS.onSetup(SLIDER), 0);\n  }\n\n\n  // Init\n  //setupSlider(_this, OPTIONS.startSlide);\n\n\n  // Expose slider API\n  return {\n    next: () => slideTo(1),\n    prev: () => slideTo(-1),\n    stop: stopSlideshow,\n    start: startSlideshow,\n    init: (startSlideIndex) => {\n      // killSlider();\n      setupSlider(_this, startSlideIndex || OPTIONS.startSlide);\n    }\n    //kill: killSlider,\n    //moveTo: (slideNr, speed) => slideTo(slideNr, true, speed)\n  };\n}\n","/*!\n * Event Burrito is a touch / mouse / pointer event unifier\n * https://github.com/wilddeer/Event-Burrito\n * Copyright Oleg Korsunsky | http://wd.dizaina.net/\n *\n * MIT License\n *\n * NOTE: Event Burrito has been modified from\n * its original form to suit this project.\n */\n\n/* exported TouchEvents */\nfunction TouchEvents(_this, options) {\n  'use strict';\n\n  const touchStateCallback = () => {},\n    o = {\n      preventDefault: true,\n      clicksAllowed: true,\n      mouse: true,\n      dragThreshold: 10, // Minimum distance to determine swipe direction\n      start: touchStateCallback,\n      move: touchStateCallback,\n      end: touchStateCallback\n    };\n        \n  // Merge user options into defaults\n  options && mergeObjects(o, options);\n\n  let start = {},\n    diff = {},\n    direction,\n    eventType,\n    axis,\n    support = {\n      pointerEvents: !!window.navigator.pointerEnabled,\n      msPointerEvents: !!window.navigator.msPointerEnabled\n    },\n    eventModel = (support.pointerEvents ? 1 : (support.msPointerEvents ? 2 : 0)),\n    events = [\n      ['touchstart', 'touchmove', 'touchend', 'touchcancel'], //touch events\n      ['pointerdown', 'pointermove', 'pointerup', 'pointercancel'], //pointer events\n      ['MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel'], //IE10 pointer events\n      ['mousedown', 'mousemove', 'mouseup', false] //mouse events\n    ],\n    checks = [\n      //touch events\n      (e) =>{\n        //skip the event if it's multitouch or pinch move\n        return (e.touches && e.touches.length > 1) || (e.scale && e.scale !== 1);\n      },\n      //pointer events\n      (e) => {\n        //Skip it, if:\n        //1. event is not primary (other pointers during multitouch),\n        //2. left mouse button is not pressed,\n        //3. mouse drag is disabled and event is not touch\n        return !e.isPrimary || (e.buttons && e.buttons !== 1) || (!o.mouse && e.pointerType !== 'touch' && e.pointerType !== 'pen');\n      },\n      //IE10 pointer events\n      (e) => {\n        //same checks as in pointer events\n        return !e.isPrimary || (e.buttons && e.buttons !== 1) || (!o.mouse && e.pointerType !== e.MSPOINTER_TYPE_TOUCH && e.pointerType !== e.MSPOINTER_TYPE_PEN);\n      },\n      //mouse events\n      (e) => {\n        //skip the event if left mouse button is not pressed\n        //in IE7-8 `buttons` is not defined, in IE9 LMB is 0\n        return (e.buttons && e.buttons !== 1);\n      }\n    ];\n\n\n  function mergeObjects(targetObj, sourceObject) {\n    for (let key in sourceObject) {\n      if (sourceObject.hasOwnProperty(key)) {\n        targetObj[key] = sourceObject[key];\n      }\n    }\n  }\n\n\n  function addEvent(el, event, func, bool) {\n    if (!event) return;\n    el.addEventListener(event, func, !!bool);\n  }\n\n\n  function removeEvent(el, event, func, bool) {\n    if (!event) return;\n    el.removeEventListener(event, func, !!bool);\n  }\n\n\n  function preventDefault(event) {\n    event.preventDefault ? event.preventDefault() : event.returnValue = false;\n  }\n\n\n  function getDiff(event) {\n    diff = {\n      X: (eventType ? event.clientX : event.touches[0].clientX) - start.X,\n      Y: (eventType ? event.clientY : event.touches[0].clientY) - start.Y,\n      time: new Date().getTime() - start.time\n    };\n  }\n\n\n  function touchStart(event, type) {\n    direction = '';\n    o.clicksAllowed = true;\n    eventType = type;\n\n    if (checks[eventType](event)) return;\n    if (preventDefault && eventType) preventDefault(event);\n\n    addEvent(document, events[eventType][1], touchMove);\n    addEvent(document, events[eventType][2], touchEnd);\n    addEvent(document, events[eventType][3], touchEnd);\n\n    start = {\n      X: eventType ? event.clientX : event.touches[0].clientX,\n      Y: eventType ? event.clientY : event.touches[0].clientY,\n      time: new Date().getTime()\n    };\n\n    for (let key in diff) {\n      diff[key] = 0;\n    }\n    o.start(event);\n  }\n\n\n  function touchMove(event) {\n    getDiff(event);\n\n    //Prevent document from scrolling while swiping because some mobile browsers flicker during transition and scroll.\n    document[`on${events[eventType][1]}`] = (e) => { preventDefault(e); };\n\n    if (!axis) {\n      axis = (o.dragThreshold < Math.abs(diff.X)) ? 'X' : (o.dragThreshold < Math.abs(diff.Y)) ? 'Y' : false;\n    } else {\n      if (axis === 'X') {\n        direction = (diff.X < 0) ? 'left' : 'right';\n        preventDefault && preventDefault(event);\n      } else if (axis === 'Y') {\n        direction = (diff.Y < 0) ? 'up' : 'down';\n      }\n    }\n\n    o.move(event, direction, diff);\n  }\n\n\n  function touchEnd(event) {\n    !o.clicksAllowed && event.target && event.target.blur && event.target.blur();\n\n    removeEvent(document, events[eventType][1], touchMove);\n    removeEvent(document, events[eventType][2], touchEnd);\n    removeEvent(document, events[eventType][3], touchEnd);\n\n    //Enable document scrolling\n    document[`on${events[eventType][1]}`] = (e) => { return true; };\n\n    o.end(event, direction, diff);\n    axis = false;\n  }\n\n\n  function init() {\n    // Bind touchstart\n    addEvent(_this, events[eventModel][0], (event) => {\n      touchStart(event, eventModel); \n    });\n    // Prevent stuff from dragging when using mouse\n    addEvent(_this, 'dragstart', preventDefault);\n    \n    // Bind mousedown if necessary\n    if (o.mouse && !eventModel) {\n      addEvent(_this, events[3][0], (event) => {\n        touchStart(event, 3);\n      });\n    }\n\n    // No clicking during touch\n    addEvent(_this, 'click', (event) => {\n      o.clicksAllowed ? touchStateCallback(event) : preventDefault(event);\n    });\n  }\n\n  // Init touch listeners\n  init();\n}"]}